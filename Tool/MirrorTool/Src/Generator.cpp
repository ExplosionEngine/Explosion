//
// Created by johnk on 2022/11/24.
//

#include <sstream>
#include <filesystem>
#include <utility>
#include <unordered_map>
#include <ranges>

#include <MirrorTool/Generator.h>
#include <Common/Hash.h>
#include <Common/String.h>
#include <Common/IO.h>

namespace MirrorTool {
    static std::string GetFullName(const Node& node)
    {
        std::string outerName = node.outerName;
        const std::string name = node.name;
        return outerName.empty() ? name : std::format("{}::{}", outerName, name);
    }

    template <uint8_t TabN>
    static std::string GetMetaDataCode(const Node& node)
    {
        std::stringstream stream;
        for (const auto& [key, value] : node.metaDatas) {
            stream << Common::newline << Common::tab<TabN> << std::format(R"(.MetaData("{}", "{}"))", key, value);
        }
        return stream.str();
    }

    static std::string GetBestMatchHeaderPath(const std::string& inputFile, const std::vector<std::string>& headerDirs)
    {
        for (const auto& headerDir : headerDirs) {
            if (headerDir.empty()) {
                return "";
            }
            if (inputFile.starts_with(headerDir)) {
                auto result = Common::StringUtils::Replace(inputFile, headerDir, "");
                return result.starts_with("/") ? result.substr(1) : result;
            }
        }
        return "";
    }

    static std::string GetHeaderNote()
    {
        std::stringstream stream;
        stream << "/* Generated by mirror tool, do not modify this file anyway. */" << Common::newline;
        return stream.str();
    }

    static std::string GetEnumCode(const EnumInfo& enumInfo)
    {
        const auto fullName = GetFullName(enumInfo);

        std::stringstream stream;
        stream << Common::newline;
        stream << Common::tab<1> << std::format("Mirror::Registry::Get()") << Common::newline;
        stream << Common::tab<2> << std::format(R"(.Enum<{}>("{}"))", fullName, fullName);
        stream << GetMetaDataCode<3>(enumInfo);
        for (const auto& element : enumInfo.elements) {
            const auto elementFullName = GetFullName(element);
            stream << Common::newline;
            stream << Common::tab<3> << std::format(R"(.Value<{}>("{}"))", elementFullName, element.name);
            stream << GetMetaDataCode<4>(element);
        }
        stream << ";" << Common::newline;
        return stream.str();
    }

    static std::string GetNamespaceEnumsCode(const NamespaceInfo& ns) // NOLINT
    {
        std::stringstream stream;
        for (const auto& e : ns.enums) {
            stream << GetEnumCode(e);
        }
        for (const auto& cns : ns.namespaces) {
            stream << GetNamespaceEnumsCode(cns);
        }
        return stream.str();
    }

    static std::string GetEnumUnloadCode(const EnumInfo& enumInfo)
    {
        const auto fullName = GetFullName(enumInfo);

        std::stringstream stream;
        stream << Common::newline;
        stream << Common::tab<2> << std::format(R"(Mirror::Registry::Get().UnloadEnum("{}");)", fullName) << Common::newline;
        return stream.str();
    }

    static std::string GetNamespaceEnumsUnloadCode(const NamespaceInfo& ns) // NOLINT
    {
        std::stringstream stream;
        for (const auto& e : ns.enums) {
            stream << GetEnumUnloadCode(e);
        }
        for (const auto& cns : ns.namespaces) {
            stream << GetNamespaceEnumsUnloadCode(cns);
        }
        return stream.str();
    }

    static std::string GetEnumsCode(const MetaInfo& metaInfo, size_t uniqueId, bool dynamic)
    {
        std::stringstream stream;
        stream << Common::newline;
        stream << std::format("Mirror::Internal::ScopedReleaser _mirrorEnumRegistry_{} = []() -> Mirror::Internal::ScopedReleaser", uniqueId) << Common::newline;
        stream << "{";
        stream << GetNamespaceEnumsCode(metaInfo.global);
        for (const auto& ns : metaInfo.namespaces) {
            stream << GetNamespaceEnumsCode(ns);
        }
        stream << Common::newline;
        if (dynamic) {
            stream << Common::tab<1> << "return Mirror::Internal::ScopedReleaser([]() -> void {" << Common::newline;
            stream << GetNamespaceEnumsUnloadCode(metaInfo.global);
            for (const auto& ns : metaInfo.namespaces) {
                stream << GetNamespaceEnumsUnloadCode(ns);
            }
            stream << Common::tab<1> << "});" << Common::newline;
        } else {
            stream << Common::tab<1> << "return Mirror::Internal::ScopedReleaser();" << Common::newline;
        }
        stream << "}();" << Common::newline;
        return stream.str();
    }

    static std::string GetFieldAccessStr(FieldAccess access)
    {
        static const std::unordered_map<FieldAccess, std::string> map = {
            { FieldAccess::pri, "Mirror::FieldAccess::faPrivate" },
            { FieldAccess::pro, "Mirror::FieldAccess::faProtected" },
            { FieldAccess::pub, "Mirror::FieldAccess::faPublic" },
        };
        return map.at(access);
    }

    template <typename FuncInfo>
    static std::unordered_map<std::string, std::vector<const FuncInfo*>> GetFunctionOverloadMap(const std::vector<FuncInfo>& infos)
    {
        std::unordered_map<std::string, std::vector<const FuncInfo*>> result;
        result.reserve(infos.size());

        for (const auto& info : infos) {
            result[info.name].emplace_back(&info);
        }
        return result;
    }

    template <typename FuncInfo>
    static std::string GetOverloadFunctionFullNameWithParams(const FuncInfo& info, const std::string& name)
    {
        std::stringstream stream;
        stream << name;
        stream << "(";
        for (auto i = 0; i < info.parameters.size(); i++) {
            const auto& paramNameAndType = info.parameters[i];
            stream << paramNameAndType.second;
            if (i != info.parameters.size() - 1) {
                stream << ", ";
            }
        }
        stream << ")";
        return stream.str();
    }

    template <typename FuncInfo>
    static std::string GetOverloadFunctionPtrType(const FuncInfo& info, const std::optional<std::string>& className = std::nullopt)
    {
        std::stringstream stream;
        stream << info.retType;
        stream << std::format("({}*)(", className.has_value() ? className.value() + "::" : "");
        for (auto i = 0; i < info.parameters.size(); i++) {
            const auto& paramNameAndType = info.parameters[i];
            stream << paramNameAndType.second;
            if (i != info.parameters.size() - 1) {
                stream << ", ";
            }
        }
        stream << ")";
        return stream.str();
    }

    static std::string GetClassCode(const ClassInfo& clazz, bool dynamic) // NOLINT
    {
        const std::string fullName = GetFullName(clazz);
        auto defaultCtorFieldAccess = FieldAccess::pub;
        for (const auto& constructor : clazz.constructors) {
            if (constructor.parameters.empty()) {
                defaultCtorFieldAccess = constructor.fieldAccess;
            }
        }
        auto detorFieldAccess = clazz.destructor.has_value() ? clazz.destructor->fieldAccess : FieldAccess::pub;

        std::string defaultCtorAndDetorFieldAccessParams = defaultCtorFieldAccess != FieldAccess::pub || detorFieldAccess != FieldAccess::pub
            ? std::format(", {}, {}", GetFieldAccessStr(defaultCtorFieldAccess), GetFieldAccessStr(detorFieldAccess))
            : "";

        std::stringstream stream;
        stream << Common::newline;
        stream << std::format("Mirror::Internal::ScopedReleaser {}::_mirrorRegistry = []() -> Mirror::Internal::ScopedReleaser ", fullName) << Common::newline;
        stream << "{" << Common::newline;
        stream << Common::tab<1> << "Mirror::Registry::Get()";
        if (clazz.baseClassName.empty()) {
            stream << Common::newline << Common::tab<2> << std::format(R"(.Class<{}, void{}>("{}"))", fullName, defaultCtorAndDetorFieldAccessParams, fullName);
        } else {
            stream << Common::newline << Common::tab<2> << std::format(R"(.Class<{}, {}{}>("{}"))", fullName, clazz.baseClassName, defaultCtorAndDetorFieldAccessParams, fullName);
        }
        stream << GetMetaDataCode<3>(clazz);
        for (const auto& constructor : clazz.constructors) {
            if (constructor.fieldAccess == FieldAccess::pub) {
                stream << Common::newline << Common::tab<3> << std::format(R"(.Constructor<{}>("{}"))", constructor.name, constructor.name);
            } else {
                stream << Common::newline << Common::tab<3> << std::format(R"(.Constructor<{}, {}>("{}"))", GetFieldAccessStr(constructor.fieldAccess), constructor.name, constructor.name);
            }
            stream << GetMetaDataCode<4>(constructor);
        }
        for (const auto& staticVariable : clazz.staticVariables) {
            const std::string variableName = GetFullName(staticVariable);
            const std::string fieldAccessStr = staticVariable.fieldAccess != FieldAccess::pub ? std::format(", {}", GetFieldAccessStr(staticVariable.fieldAccess)) : "";
            stream << Common::newline << Common::tab<3> << std::format(R"(.StaticVariable<&{}{}>("{}"))", variableName, fieldAccessStr, staticVariable.name);
            stream << GetMetaDataCode<4>(staticVariable);
        }

        for (const auto staticFunctionOverloadMap = GetFunctionOverloadMap(clazz.staticFunctions);
            const auto& overloads : staticFunctionOverloadMap | std::views::values) {
            if (overloads.size() > 1) {
                for (const auto& overload : overloads) {
                    const ClassFunctionInfo& staticFunction = *overload;
                    const std::string functionName = GetFullName(staticFunction);
                    const std::string shortFunctionNameWithParams = GetOverloadFunctionFullNameWithParams(staticFunction, staticFunction.name);
                    const std::string ptrType = GetOverloadFunctionPtrType(staticFunction);
                    const std::string fieldAccessStr = staticFunction.fieldAccess != FieldAccess::pub ? std::format(", {}", GetFieldAccessStr(staticFunction.fieldAccess)) : "";
                    stream << Common::newline << Common::tab<3> << std::format(R"(.StaticFunction<static_cast<{}>(&{}){}>("{}"))", ptrType, functionName, fieldAccessStr, shortFunctionNameWithParams);
                    stream << GetMetaDataCode<4>(staticFunction);
                }
            } else {
                const ClassFunctionInfo& staticFunction = *overloads[0];
                const std::string functionName = GetFullName(staticFunction);
                const std::string fieldAccessStr = staticFunction.fieldAccess != FieldAccess::pub ? std::format(", {}", GetFieldAccessStr(staticFunction.fieldAccess)) : "";
                stream << Common::newline << Common::tab<3> << std::format(R"(.StaticFunction<&{}{}>("{}"))", functionName, fieldAccessStr, staticFunction.name);
                stream << GetMetaDataCode<4>(staticFunction);
            }
        }

        for (const auto& variable : clazz.variables) {
            const std::string variableName = GetFullName(variable);
            const std::string fieldAccessStr = variable.fieldAccess != FieldAccess::pub ? std::format(", {}", GetFieldAccessStr(variable.fieldAccess)) : "";
            stream << Common::newline << Common::tab<3> << std::format(R"(.MemberVariable<&{}{}>("{}"))", variableName, fieldAccessStr, variable.name);
            stream << GetMetaDataCode<4>(variable);
        }

        for (const auto memberFunctionOverloadMap = GetFunctionOverloadMap(clazz.functions);
            const auto& overloads : memberFunctionOverloadMap | std::views::values) {
            if (overloads.size() > 1) {
                for (const auto& overload : overloads) {
                    const ClassFunctionInfo& function = *overload;
                    const std::string functionName = GetFullName(function);
                    const std::string shortFunctionNameWithParams = GetOverloadFunctionFullNameWithParams(function, function.name) + (overload->isConst ? " const" : "");
                    const std::string ptrType = GetOverloadFunctionPtrType(function, fullName) + (overload->isConst ? " const" : "");
                    const std::string fieldAccessStr = function.fieldAccess != FieldAccess::pub ? std::format(", {}", GetFieldAccessStr(function.fieldAccess)) : "";
                    stream << Common::newline << Common::tab<3> << std::format(R"(.MemberFunction<static_cast<{}>(&{}){}>("{}"))", ptrType, functionName, fieldAccessStr, shortFunctionNameWithParams);
                    stream << GetMetaDataCode<4>(function);
                }
            } else {
                const ClassFunctionInfo& function = *overloads[0];
                const std::string functionName = GetFullName(function);
                const std::string fieldAccessStr = function.fieldAccess != FieldAccess::pub ? std::format(", {}", GetFieldAccessStr(function.fieldAccess)) : "";
                stream << Common::newline << Common::tab<3> << std::format(R"(.MemberFunction<&{}{}>("{}"))", functionName, fieldAccessStr, function.name);
                stream << GetMetaDataCode<4>(function);
            }
        }

        stream << ";" << Common::newline;
        if (dynamic) {
            stream << Common::tab<1> << "return Mirror::Internal::ScopedReleaser([]() -> void {" << Common::newline;
            stream << Common::tab<2> << std::format(R"(Mirror::Registry::Get().UnloadClass("{}");)", fullName) << Common::newline;
            stream << Common::tab<1> << "});" << Common::newline;
        } else {
            stream << Common::tab<1> << "return Mirror::Internal::ScopedReleaser();" << Common::newline;
        }
        stream << "}();" << Common::newline;

        stream << Common::newline;
        stream << std::format("const Mirror::Class& {}::GetStaticClass()", fullName) << Common::newline;
        stream << "{" << Common::newline;
        stream << Common::tab<1> << std::format("static const Mirror::Class& clazz = Mirror::Class::Get<{}>();", fullName) << Common::newline;
        stream << Common::tab<1> << "return clazz;" << Common::newline;
        stream << "}" << Common::newline;
        stream << std::format("const Mirror::Class& {}::GetClass() const", fullName) << Common::newline;
        stream << "{" << Common::newline;
        stream << Common::tab<1> << std::format("static const Mirror::Class& clazz = Mirror::Class::Get<{}>();", fullName) << Common::newline;
        stream << Common::tab<1> << "return clazz;" << Common::newline;
        stream << "}" << Common::newline;

        for (const auto& internalClass : clazz.classes) {
            stream << GetClassCode(internalClass, dynamic);
        }
        return stream.str();
    }

    static std::string GetNamespaceClassesCode(const NamespaceInfo& ns, bool dynamic) // NOLINT
    {
        std::stringstream stream;
        for (const auto& clazz : ns.classes) {
            stream << GetClassCode(clazz, dynamic);
        }
        for (const auto& cns : ns.namespaces) {
            stream << GetNamespaceClassesCode(cns, dynamic);
        }
        return stream.str();
    }

    static std::string GetClassesCode(const MetaInfo& metaInfo, bool dynamic)
    {
        std::stringstream stream;
        stream << GetNamespaceClassesCode(metaInfo.global, dynamic);
        for (const auto& ns : metaInfo.namespaces) {
            stream << GetNamespaceClassesCode(ns, dynamic);
        }
        return stream.str();
    }

    static std::string GetNamespaceGlobalCode(const NamespaceInfo& ns) // NOLINT
    {
        std::stringstream stream;
        for (const auto& var : ns.variables) {
            const auto fullName = GetFullName(var);

            stream << Common::newline;
            stream << Common::tab<1> << "Mirror::Registry::Get()" << Common::newline;
            stream << Common::tab<2> << ".Global()" << Common::newline;
            stream << Common::tab<3> << std::format(R"(.Variable<&{}>("{}"))", fullName, fullName);
            stream << GetMetaDataCode<4>(var);
            stream << ";" << Common::newline;
        }

        for (const auto funcOverloadMap = GetFunctionOverloadMap(ns.functions);
            const auto& overloads : funcOverloadMap | std::views::values) {
            if (overloads.size() > 1) {
                for (const auto& overload : overloads) {
                    const FunctionInfo& func = *overload;
                    const auto fullName = GetFullName(func);
                    const auto fullNameWithParams = GetOverloadFunctionFullNameWithParams(func, GetFullName(func));;
                    const auto ptrType = GetOverloadFunctionPtrType(func);

                    stream << Common::newline;
                    stream << Common::tab<1> << "Mirror::Registry::Get()" << Common::newline;
                    stream << Common::tab<2> << ".Global()" << Common::newline;
                    stream << Common::tab<3> << std::format(R"(.Function<static_cast<{}>(&{})>("{}"))", ptrType, fullName, fullNameWithParams);
                    stream << GetMetaDataCode<4>(func);
                    stream << ";" << Common::newline;
                }
            } else {
                const FunctionInfo& func = *overloads[0];
                const auto fullName = GetFullName(func);

                stream << Common::newline;
                stream << Common::tab<1> << "Mirror::Registry::Get()" << Common::newline;
                stream << Common::tab<2> << ".Global()" << Common::newline;
                stream << Common::tab<3> << std::format(R"(.Function<&{}>("{}"))", fullName, fullName);
                stream << GetMetaDataCode<4>(func);
                stream << ";" << Common::newline;
            }
        }

        for (const auto& cns : ns.namespaces) {
            stream << GetNamespaceGlobalCode(cns);
        }
        return stream.str();
    }

    static std::string GetNamespaceGlobalUnloadCode(const NamespaceInfo& ns)
    {
        std::stringstream stream;
        for (const auto& var : ns.variables) {
            const auto fullName = GetFullName(var);
            stream << Common::newline;
            stream << Common::tab<2> << std::format(R"(Mirror::Registry::Get().Global().UnloadVariable("{}");)", fullName) << Common::newline;
        }

        for (const auto funcOverloadMap = GetFunctionOverloadMap(ns.functions);
            const auto& overloads : funcOverloadMap | std::views::values) {
            if (overloads.size() > 1) {
                for (const auto& overload : overloads) {
                    const FunctionInfo& func = *overload;
                    const auto fullNameWithParams = GetOverloadFunctionFullNameWithParams(func, GetFullName(func));;

                    stream << Common::newline;
                    stream << Common::tab<2> << std::format(R"("Mirror::Registry::Get().Global().UnloadFunction("{}");")", fullNameWithParams) << Common::newline;
                }
            } else {
                const FunctionInfo& func = *overloads[0];
                const auto fullName = GetFullName(func);

                stream << Common::newline;
                stream << Common::tab<2> << std::format(R"(Mirror::Registry::Get().Global().UnloadFunction<&{}>("{}"))", fullName, fullName) << Common::newline;
            }
        }

        for (const auto& cns : ns.namespaces) {
            stream << GetNamespaceGlobalCode(cns);
        }
        return stream.str();
    }

    static std::string GetGlobalCode(const MetaInfo& metaInfo, size_t uniqueId, bool dynamic)
    {
        std::stringstream stream;
        stream << Common::newline;
        stream << std::format("Mirror::Internal::ScopedReleaser _globalRegistry_{} = []() -> Mirror::Internal::ScopedReleaser", uniqueId) << Common::newline;
        stream << "{";
        stream << GetNamespaceGlobalCode(metaInfo.global);
        for (const auto& ns : metaInfo.namespaces) {
            stream << GetNamespaceGlobalCode(ns);
        }
        stream << Common::newline;
        if (dynamic) {
            stream << Common::tab<1> << "return Mirror::Internal::ScopedReleaser([]() -> void {" << Common::newline;
            stream << GetNamespaceGlobalCode(metaInfo.global);
            for (const auto& ns : metaInfo.namespaces) {
                stream << GetNamespaceGlobalCode(ns);
            }
            stream << Common::tab<1> << "});" << Common::newline;
        } else {
            stream << Common::tab<1> << "return Mirror::Internal::ScopedReleaser();" << Common::newline;
        }
        stream << "}();" << Common::newline;
        return stream.str();
    }
}

namespace MirrorTool {
    Generator::Generator(std::string inInputFile, std::string inOutputFile, std::vector<std::string> inHeaderDirs, const MetaInfo& inMetaInfo, bool inDynamic)
        : metaInfo(inMetaInfo)
        , inputFile(std::move(inInputFile))
        , outputFile(std::move(inOutputFile))
        , headerDirs(std::move(inHeaderDirs))
        , dynamic(inDynamic)
    {
    }

    Generator::~Generator() = default;

    Generator::Result Generator::Generate() const
    {
        if (const std::filesystem::path parentPath = std::filesystem::path(outputFile).parent_path();
            !std::filesystem::exists(parentPath)) {
            std::filesystem::create_directories(parentPath);
        }

        std::ifstream inFile(inputFile);
        if (inFile.fail()) {
            return std::make_pair(false, "failed to open input file");
        }

        std::ofstream outFile(outputFile);
        if (outFile.fail()) {
            return std::make_pair(false, "failed to open output file");
        }

        auto result = GenerateCode(inFile, outFile, Common::HashUtils::CityHash(outputFile.data(), outputFile.size()));
        outFile.close();
        return result;
    }

    Generator::Result Generator::GenerateCode(std::ifstream& inFile, std::ofstream& outFile, size_t uniqueId) const
    {
        std::string bestMatchHeaderPath = GetBestMatchHeaderPath(inputFile, headerDirs);
        if (bestMatchHeaderPath.empty()) {
            return std::make_pair(false, "failed to compute best match header path");
        }

        outFile << GetHeaderNote() << Common::newline;
        outFile << std::format("#include <{}>", bestMatchHeaderPath) << Common::newline;
        outFile << "#include <Mirror/Registry.h>" << Common::newline;
        outFile << GetGlobalCode(metaInfo, uniqueId, dynamic);
        outFile << GetEnumsCode(metaInfo, uniqueId, dynamic);
        outFile << GetClassesCode(metaInfo, dynamic);
        return std::make_pair(true, "");
    }
}
